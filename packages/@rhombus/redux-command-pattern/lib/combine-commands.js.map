{"version":3,"file":"combine-commands.js","sourceRoot":"","sources":["../src/combine-commands.ts"],"names":[],"mappings":";AAyBA;;;;;;;;GAQG;AACH,sFAAsF;AACtF,sGAAsG;AACtG,gBAAgB;AAChB,QAAQ","sourcesContent":["\ndeclare const $CombinedState: unique symbol;\ninterface EmptyObject {\n    readonly [$CombinedState]?: undefined\n  }\n  export type CombinedState<S> = EmptyObject & S\n\n  /**\n   * Recursively makes combined state objects partial. Only combined state _root\n   * objects_ (i.e. the generated higher level object with keys mapping to\n   * individual reducers) are partial.\n   */\n  export type PreloadedState<S> = Required<S> extends EmptyObject\n  ? S extends CombinedState<infer S1>\n    ? {\n        [K in keyof S1]?: S1[K] extends object ? PreloadedState<S1[K]> : S1[K]\n      }\n    : never\n  : {\n      [K in keyof S]: S[K] extends string | number | boolean | symbol\n        ? S[K]\n        : PreloadedState<S[K]>\n    }\n\n\n/**\n *\n * this function needs to:\n * take in a Record<string, CommandFnOrMap>\n * - keys in this record must correspond to State shape\n * - these command functions must take in and return the sliced state type\n *\n *\n */\n// export function combineReducers<M extends ReducersMapObject<any, any>>(commands: M)\n//     : CommandFnMap <CombinedState<StateFromReducersMapObject<M>>, ActionFromReducersMapObject<M>> {\n//     throw '';\n//     }\n"]}