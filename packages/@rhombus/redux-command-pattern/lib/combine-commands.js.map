{"version":3,"file":"combine-commands.js","sourceRoot":"","sources":["../src/combine-commands.ts"],"names":[],"mappings":";AAyBA;;;;;;;;GAQG;AACH,sFAAsF;AACtF,sGAAsG;AACtG,gBAAgB;AAChB,QAAQ","sourcesContent":["\r\ndeclare const $CombinedState: unique symbol;\r\ninterface EmptyObject {\r\n    readonly [$CombinedState]?: undefined\r\n  }\r\n  export type CombinedState<S> = EmptyObject & S\r\n\r\n  /**\r\n   * Recursively makes combined state objects partial. Only combined state _root\r\n   * objects_ (i.e. the generated higher level object with keys mapping to\r\n   * individual reducers) are partial.\r\n   */\r\n  export type PreloadedState<S> = Required<S> extends EmptyObject\r\n  ? S extends CombinedState<infer S1>\r\n    ? {\r\n        [K in keyof S1]?: S1[K] extends object ? PreloadedState<S1[K]> : S1[K]\r\n      }\r\n    : never\r\n  : {\r\n      [K in keyof S]: S[K] extends string | number | boolean | symbol\r\n        ? S[K]\r\n        : PreloadedState<S[K]>\r\n    }\r\n\r\n\r\n/**\r\n *\r\n * this function needs to:\r\n * take in a Record<string, CommandFnOrMap>\r\n * - keys in this record must correspond to State shape\r\n * - these command functions must take in and return the sliced state type\r\n *\r\n *\r\n */\r\n// export function combineReducers<M extends ReducersMapObject<any, any>>(commands: M)\r\n//     : CommandFnMap <CombinedState<StateFromReducersMapObject<M>>, ActionFromReducersMapObject<M>> {\r\n//     throw '';\r\n//     }\r\n"]}