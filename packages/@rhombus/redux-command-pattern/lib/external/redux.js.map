{"version":3,"file":"redux.js","sourceRoot":"","sources":["../../src/external/redux.ts"],"names":[],"mappings":"","sourcesContent":["export interface Action<T = any> {\n    type: T;\n}\n\n\nexport interface AnyAction extends Action {\n    // Allows any extra properties to be defined in an action.\n    [extraProps: string]: any;\n}\n\n\nexport type Reducer<S = any, A extends Action = AnyAction> = (\n    state: S | undefined,\n    action: A\n) => S;\n\n/**\n * A store is an object that holds the application's state tree.\n * There should only be a single store in a Redux app, as the composition\n * happens on the reducer level.\n *\n * @template S The type of state held by this store.\n * @template A the type of actions which may be dispatched by this store.\n */\n export interface Store<S = any, A extends Action = AnyAction> {\n    /**\n     * Dispatches an action. It is the only way to trigger a state change.\n     *\n     * The `reducer` function, used to create the store, will be called with the\n     * current state tree and the given `action`. Its return value will be\n     * considered the **next** state of the tree, and the change listeners will\n     * be notified.\n     *\n     * The base implementation only supports plain object actions. If you want\n     * to dispatch a Promise, an Observable, a thunk, or something else, you\n     * need to wrap your store creating function into the corresponding\n     * middleware. For example, see the documentation for the `redux-thunk`\n     * package. Even the middleware will eventually dispatch plain object\n     * actions using this method.\n     *\n     * @param action A plain object representing “what changed”. It is a good\n     *   idea to keep actions serializable so you can record and replay user\n     *   sessions, or use the time travelling `redux-devtools`. An action must\n     *   have a `type` property which may not be `undefined`. It is a good idea\n     *   to use string constants for action types.\n     *\n     * @returns For convenience, the same action object you dispatched.\n     *\n     * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n     * return something else (for example, a Promise you can await).\n     */\n    dispatch: Dispatch<A>\n\n    /**\n     * Reads the state tree managed by the store.\n     *\n     * @returns The current state tree of your application.\n     */\n    getState(): S\n\n    /**\n     * Adds a change listener. It will be called any time an action is\n     * dispatched, and some part of the state tree may potentially have changed.\n     * You may then call `getState()` to read the current state tree inside the\n     * callback.\n     *\n     * You may call `dispatch()` from a change listener, with the following\n     * caveats:\n     *\n     * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n     * If you subscribe or unsubscribe while the listeners are being invoked,\n     * this will not have any effect on the `dispatch()` that is currently in\n     * progress. However, the next `dispatch()` call, whether nested or not,\n     * will use a more recent snapshot of the subscription list.\n     *\n     * 2. The listener should not expect to see all states changes, as the state\n     * might have been updated multiple times during a nested `dispatch()` before\n     * the listener is called. It is, however, guaranteed that all subscribers\n     * registered before the `dispatch()` started will be called with the latest\n     * state by the time it exits.\n     *\n     * @param listener A callback to be invoked on every dispatch.\n     * @returns A function to remove this change listener.\n     */\n    subscribe(listener: () => void): Unsubscribe\n\n    /**\n     * Replaces the reducer currently used by the store to calculate the state.\n     *\n     * You might need this if your app implements code splitting and you want to\n     * load some of the reducers dynamically. You might also need this if you\n     * implement a hot reloading mechanism for Redux.\n     *\n     * @param nextReducer The reducer for the store to use instead.\n     */\n    replaceReducer(nextReducer: Reducer<S, A>): void\n\n    /**\n     * Interoperability point for observable/reactive libraries.\n     * @returns {observable} A minimal observable of state changes.\n     * For more information, see the observable proposal:\n     * https://github.com/tc39/proposal-observable\n     */\n    [Symbol.observable](): Observable<S>\n  }\n\n  export interface Dispatch<A extends Action = AnyAction> {\n    <T extends A>(action: T): T\n  }\n\n  /**\n   * Function to remove listener added by `Store.subscribe()`.\n   */\n  export interface Unsubscribe {\n    (): void\n  }\n  export type Observable<T> = {\n    /**\n     * The minimal observable subscription method.\n     * @param {Object} observer Any object that can be used as an observer.\n     * The observer object should have a `next` method.\n     * @returns {subscription} An object with an `unsubscribe` method that can\n     * be used to unsubscribe the observable from the store, and prevent further\n     * emission of values from the observable.\n     */\n    subscribe: (observer: Observer<T>) => { unsubscribe: Unsubscribe }\n    [Symbol.observable](): Observable<T>\n  }\n\n  /**\n   * An Observer is used to receive data from an Observable, and is supplied as\n   * an argument to subscribe.\n   */\n  export type Observer<T> = {\n    next?(value: T): void\n  }\n"]}