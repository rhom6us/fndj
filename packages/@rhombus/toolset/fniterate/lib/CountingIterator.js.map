{"version":3,"file":"CountingIterator.js","sourceRoot":"","sources":["../src/CountingIterator.ts"],"names":[],"mappings":"AAUA,6DAA6D;AAC7D,MAAM,OAAO,gBAAgB;IAKI;IAJrB,YAAY,GAAG,CAAC,CAAC;IACzB,CAAC,MAAM,CAAC,QAAQ,CAAC;QACb,OAAO,IAAI,CAAC;IAChB,CAAC;IACD,YAA6B,OAAoB;QAApB,YAAO,GAAP,OAAO,CAAa;QAC7C,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YACjB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;SAC3B;QACD,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;YAChB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;SAC1B;IACL,CAAC;IAGD,4GAA4G;IACpG,UAAU,CAAC,MAAyB;QACxC,IAAI,MAAM,CAAC,IAAI,EAAE;YACb,OAAO,EAAE,GAAG,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,YAAY,EAAE,EAAE,CAAC;SACzD;aAAM;YACH,OAAO,EAAE,GAAG,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,YAAY,EAAE,EAAE,EAAE,CAAC;SAC3D;IACL,CAAC;IACD,IAAI,CAAC,GAAG,IAAQ;QACZ,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QAC1C,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;IAAA,CAAC;IACF,MAAM;QACF,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAO,EAAE,CAAC;QACtC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAEnC,CAAC;IACD,KAAK,CAAE,CAAO;QACV,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,KAAM,CAAC,CAAC,CAAC,CAAC;QACtC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;CACJ","sourcesContent":["export interface CountingIteratorYieldResult<T> extends IteratorYieldResult<T> {\r\n    index: number;\r\n}\r\nexport interface CountingIteratorReturnResult<TReturn> extends IteratorReturnResult<TReturn> {\r\n    count: number;\r\n}\r\n\r\nexport type CountingIteratorResult<T, TReturn = any> = CountingIteratorYieldResult<T> | CountingIteratorReturnResult<TReturn>;\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport class CountingIterator<T> implements IterableIterator<T> {\r\n    private currentIndex = 0;\r\n    [Symbol.iterator]() {\r\n        return this;\r\n    }\r\n    constructor(private readonly _source: Iterator<T>) {\r\n        if (!_source.return) {\r\n            this.return = undefined;\r\n        }\r\n        if (!_source.throw) {\r\n            this.throw = undefined;\r\n        }\r\n    }\r\n\r\n\r\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\r\n    private makeResult(result: IteratorResult<T>) {\r\n        if (result.done) {\r\n            return { ...result, ...{ count: this.currentIndex } };\r\n        } else {\r\n            return { ...result, ...{ index: this.currentIndex++ } };\r\n        }\r\n    }\r\n    next(...args: []): CountingIteratorResult<T> {\r\n        const result = this._source.next(...args);\r\n        return this.makeResult(result);\r\n    };\r\n    return?(): CountingIteratorResult<T> {\r\n        const result = this._source.return!();\r\n        return this.makeResult(result);\r\n\r\n    }\r\n    throw?(e?: any): CountingIteratorResult<T> {\r\n        const result = this._source.throw!(e);\r\n        return this.makeResult(result);\r\n    }\r\n}\r\n"]}