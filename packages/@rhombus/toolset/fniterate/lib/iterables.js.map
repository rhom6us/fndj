{"version":3,"file":"iterables.js","sourceRoot":"","sources":["../src/iterables.ts"],"names":[],"mappings":"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","sourcesContent":["import { CountingIterator } from './CountingIterator';\n\nexport interface Grouping<T, TKey> extends Iterable<T> {\n    key: TKey;\n}\nexport function first<V>(source: Iterable<V>, predicate?: (this: typeof source, item: V, index: number) => boolean) {\n    let index = 0;\n    for (const item of source) {\n        if (predicate?.call(source, item, index++) ?? true) {\n            return item;\n        }\n    }\n    throw new RangeError(\"Sequence contains no elements\");\n}\n\nexport function firstOrDefault<V, D = undefined>(source: Iterable<V>, defaultValue: D, predicate?: (this: typeof source, item: V, index: number) => boolean): D | V {\n    let index = 0;\n    for (const item of source) {\n        if (predicate?.call(source, item, index++) ?? true) {\n            return item;\n        }\n    }\n    return defaultValue;\n}\nexport function* filter<V>(source: Iterable<V>, predicate: (this: typeof source, item: V, index: number) => boolean) {\n    let index = 0;\n    for (const item of source) {\n        if (predicate.call(source, item, index++)) {\n            yield item;\n        }\n    }\n}\nexport function* map<V, R>(source: Iterable<V>, selector: (this: typeof source, item: V, index: number) => R): Iterable<R> {\n    let index = 0;\n    for (const item of source) {\n        yield selector.call(source, item, index++);\n    }\n}\nexport function* flatMap<V, R>(source: Iterable<V>, selector: (this: typeof source, item: V, index: number) => Iterable<R>): Iterable<R> {\n    let index = 0;\n    for (const sublist of source) {\n        yield* selector.call(source, sublist, index++);\n    }\n}\nexport function skip<V>(source: Iterable<V>, count: number): Iterable<V> {\n    const iter = source instanceof CountingIterator ? source : new CountingIterator(source[Symbol.iterator]());\n    let current = iter.next();\n\n    while (!current.done && current.index < count++) {\n        current = iter.next();\n    }\n    return iter;\n\n}\nexport function* iterateCount<V>(source: Iterable<V>) {\n    const iter = source instanceof CountingIterator ? source : new CountingIterator(source[Symbol.iterator]());\n    let current = iter.next();\n    while (!current.done) {\n        yield [current.value, current.index];\n        current = iter.next();\n    }\n}\nexport function* take<V>(source: Iterable<V>, count: number): Iterable<V> {\n    for (const [item, index] of iterateCount(source)) {\n        if (index >= count) {\n            return;\n        }\n        yield item;\n    }\n}\n"]}