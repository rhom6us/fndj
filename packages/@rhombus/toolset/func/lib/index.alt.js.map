{"version":3,"file":"index.alt.js","sourceRoot":"","sources":["../src/index.alt.ts"],"names":[],"mappings":"","sourcesContent":["\nexport declare const $: unique symbol;\nexport type $ = typeof $;\n\ntype Replace<T, R> =\n    T extends $ ? R :\n    T extends string ? T :\n    T extends any[] ? ReplaceArray<T, R> :\n    T extends Promise<infer X> ? Promise<Replace<X, R>> :\n    T extends PromiseLike<infer X> ? PromiseLike<Replace<X, R>> :\n    T extends Generator<infer X> ? Generator<Replace<X, R>> :\n    T extends AsyncGenerator<infer X> ? AsyncGenerator<Replace<X, R>> :\n    T extends MessageEvent<infer X> ? MessageEvent<Replace<X, R>> :\n    T extends Map<infer X, infer Y> ? Map<Replace<X, R>, Replace<Y, R>> :\n    T extends Set<infer X> ? Set<Replace<X, R>> :\n    T extends Iterable<infer X> ? Iterable<Replace<X, R>> :\n    T extends AsyncIterable<infer X> ? AsyncIterable<Replace<X, R>> :\n    T extends _Ctor<infer X, infer Y> ? _Ctor<ReplaceArray<X, R>, Replace<Y, R>> :\n    T extends _ACtor<infer X, infer Y> ? _ACtor<ReplaceArray<X, R>, Replace<Y, R>> :\n    T extends _Func<infer X, infer Y> ? _Func<ReplaceArray<X, R>, Replace<Y, R>> :\n    T extends Record<any, any> ? {\n        [K in keyof T as Replace<K, R>] : Replace<T[K], R>\n    } \n    : T;\n    \n\ntype ReplaceArray<Arr extends any[], R, done extends any[] = []> =\n    // Arr extends [infer item, ...infer rest] ? [Replace<item, R>, ...ReplaceArray<rest, R>] : Arr\n    Arr extends [infer item, ...infer rest] ? ReplaceArray<rest, R, [...done, Replace<item, R>]> :\n    Arr extends [] ? done :\n    Arr extends $[] ? R[] :\n    Arr extends any[] ? Arr :\n    {ERROR:{'@rhombus/func':{Arr:Arr, R:R, done:done}}};\n\n\ntype _ = { readonly _: unique symbol; };\n\ntype _Func<Args extends any[], Return>\n    = (...args: Args) => Return\n\ntype _FuncG<Args extends any[], Return, Constraint>\n    = _ extends Constraint // see if Constraint is 'any'\n    ? <T>(...args: Replace<Args, T>) => Replace<Return, T>\n    : <T extends Constraint>(...args: Replace<Args, T>) => Replace<Return, T>;\n\nexport type Func<Args extends any[] = any[], Return = any, Constraint = any>\n    = Replace<[Args, Return], 'asdf'> extends Replace<[Args, Return], 'qwer'> // see if there are any placeholders for generic usage\n    ? _Func<Args, Return>\n    : _FuncG<Args, Return, Constraint>;\n\nexport type AsyncFunc<Args extends any[] = any[], Return = any, Constraint = any> = Func<Args, Promise<Awaited<Return>>, Constraint>;\n\nexport type Action<Args extends any[] = any[], Constraint = any> = Func<Args, void, Constraint>;\nexport type AsyncAction<Args extends any[] = any[], Constraint = any> = AsyncFunc<Args, void, Constraint>;\n\nexport type Sub<Args extends any[] = any[], Constraint = any> = Action<Args, Constraint>;\nexport type AsyncSub<Args extends any[] = any[], Constraint = any> = AsyncAction<Args, Constraint>;\n\n\n\ninterface _Ctor<Args extends any[], Instance> {\n    new(...args: Args): Instance;\n    readonly prototype: Instance;\n}\ntype _CtorG<Args extends any[], Instance, Constraint> =\n    _ extends Constraint ? {\n        new <T>(...args: Replace<Args, T>): Replace<Instance, T>;\n        readonly prototype: Replace<Instance, any>;\n    } : {\n        new <T extends Constraint>(...args: Replace<Args, T>): Replace<Instance, T>;\n        readonly prototype: Replace<Instance, any>;\n    };\n\nexport type Ctor<Args extends any[] = any[], Instance = any, Constraint = any>\n    = Replace<[Args, Instance], 'asdf'> extends Replace<[Args, Instance], 'qwer'>\n    ? _Ctor<Args, Instance>\n    : _CtorG<Args, Instance, Constraint>;\n\n\n\ntype _ACtorFn<Args extends any[], Instance>\n    = abstract new (...args: Args) => Instance;\ninterface _ACtor<Args extends any[], Instance> extends _ACtorFn<Args, Instance> {\n    readonly prototype: Instance;\n}\n\ntype _ACtorGAnyFn<Args extends any[], Instance>\n    = abstract new <T>(...args: Replace<Args, T>) => Replace<Instance, T>;\ninterface _ACtorGAny<Args extends any[], Instance> extends _ACtorGAnyFn<Args, Instance> {\n    readonly prototype: Replace<Instance, any>;\n}\ntype _ACtorGConstrainedFn<Args extends any[], Instance, Constraint>\n    = abstract new <T extends Constraint>(...args: Replace<Args, T>) => Replace<Instance, T>;\ninterface _ACtorGConstrained<Args extends any[], Instance, Constraint> extends _ACtorGConstrainedFn<Args, Instance, Constraint> {\n    readonly prototype: Replace<Instance, any>;\n}\n\ntype _ACtorG<Args extends any[], Instance, Constraint>\n    = _ extends Constraint\n    ? _ACtorGAny<Args, Instance>\n    : _ACtorGConstrained<Args, Instance, Constraint>\n\nexport type AbstractCtor<Args extends any[] = any[], Instance = any, Constraint = any>\n    = Replace<[Args, Instance], 'asdf'> extends Replace<[Args, Instance], 'qwer'>\n    ? _ACtor<Args, Instance>\n    : _ACtorG<Args, Instance, Constraint>;\n\n"]}