{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,sDAAsD","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/**\n * ASCII: 32\n * regex: \\s\n */\ntype SpaceChar = ' ';\n\n/**\n * regex: \\S\n */\ntype NonSpaceChar = Exclude<AnyChar, SpaceChar>;\n\n/**\n * ASCII: 33-47\n */\ntype SymbolChar1 = '!' | '\"' | '#' | '$' | '%' | '&' | \"'\" | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/';\n\n/**\n * ASCII: 48-57\n * regex: \\d\n */\ntype DigitChar = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';\n\n/**\n * regex: \\D\n */\ntype NonDigitChar = Exclude<AnyChar, DigitChar>;\n\n/**\n * ASCII: 58 - 64\n */\ntype SymbolChar2 = ':' | ';' | '<' | '=' | '>' | '?' | '@';\n\n/**\n * ASCII: 65 - 90\n * regex: [A-Z]\n */\ntype UpperCaseChar = Uppercase<LowerCaseChar>;\n\n/**\n * ASCII: 91 - 96\n */\ntype SymbolChar3 = '[' | '\\\\' | ']' | '^' | '_' | '`';\n\n/**\n * ASCII: 97 - 122\n * regex: [a-z]\n */\ntype LowerCaseChar =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z';\n\n/**\n * ASCII: 123 - 126\n */\ntype SymbolChar4 = '{' | '|' | '}' | '~';\n\ntype SymbolChar = SymbolChar1 | SymbolChar2 | SymbolChar3 | SymbolChar4;\ntype LetterChar = UpperCaseChar | LowerCaseChar;\n\n/**\n * almost the same as string but excludes things like \\t, \\n, etc that is highly unlikely one would want to be explicitely typed\n */\ntype AnyChar = LetterChar | DigitChar | SymbolChar | SpaceChar;\n\n/**\n * regez: \\w\n */\ntype WordChar = LetterChar | DigitChar | '_';\n\n/**\n * regez: \\W\n */\ntype NonWordChar = Exclude<AnyChar, WordChar>;\n\ntype Replace<T, P extends string, R extends string> = T extends `${infer X}${P}${infer Y}` ? `${X}${R}${Replace<Y, P, R>}` : T;\n\n// type Upper<T extends string> =\n//     T extends `${infer X}a${infer Y}` ? `${Upper<X>}A${Upper<Y>}` :\n//     T extends `${infer X}b${infer Y}` ? `${Upper<X>}B${Upper<Y>}` :\n//     T extends `${infer X}c${infer Y}` ? `${Upper<X>}C${Upper<Y>}` :\n//     T extends `${infer X}d${infer Y}` ? `${Upper<X>}D${Upper<Y>}` :\n//     T extends `${infer X}e${infer Y}` ? `${Upper<X>}E${Upper<Y>}` :\n//     T extends `${infer X}f${infer Y}` ? `${Upper<X>}F${Upper<Y>}` :\n//     T extends `${infer X}g${infer Y}` ? `${Upper<X>}G${Upper<Y>}` :\n//     T extends `${infer X}h${infer Y}` ? `${Upper<X>}H${Upper<Y>}` :\n//     T extends `${infer X}i${infer Y}` ? `${Upper<X>}I${Upper<Y>}` :\n//     T extends `${infer X}j${infer Y}` ? `${Upper<X>}J${Upper<Y>}` :\n//     T extends `${infer X}k${infer Y}` ? `${Upper<X>}K${Upper<Y>}` :\n//     T extends `${infer X}l${infer Y}` ? `${Upper<X>}L${Upper<Y>}` :\n//     T extends `${infer X}m${infer Y}` ? `${Upper<X>}M${Upper<Y>}` :\n//     T extends `${infer X}n${infer Y}` ? `${Upper<X>}N${Upper<Y>}` :\n//     T extends `${infer X}o${infer Y}` ? `${Upper<X>}O${Upper<Y>}` :\n//     T extends `${infer X}p${infer Y}` ? `${Upper<X>}P${Upper<Y>}` :\n//     T extends `${infer X}q${infer Y}` ? `${Upper<X>}Q${Upper<Y>}` :\n//     T extends `${infer X}r${infer Y}` ? `${Upper<X>}R${Upper<Y>}` :\n//     T extends `${infer X}s${infer Y}` ? `${Upper<X>}S${Upper<Y>}` :\n//     T extends `${infer X}t${infer Y}` ? `${Upper<X>}T${Upper<Y>}` :\n//     T extends `${infer X}u${infer Y}` ? `${Upper<X>}U${Upper<Y>}` :\n//     T extends `${infer X}v${infer Y}` ? `${Upper<X>}V${Upper<Y>}` :\n//     T extends `${infer X}w${infer Y}` ? `${Upper<X>}W${Upper<Y>}` :\n//     T extends `${infer X}x${infer Y}` ? `${Upper<X>}X${Upper<Y>}` :\n//     T extends `${infer X}y${infer Y}` ? `${Upper<X>}Y${Upper<Y>}` :\n//     T extends `${infer X}z${infer Y}` ? `${Upper<X>}Z${Upper<Y>}` :\n//     T;\n// type Lower<T extends string> =\n//     T extends `${infer X}A${infer Y}` ? `${Lower<X>}a${Lower<Y>}` :\n//     T extends `${infer X}B${infer Y}` ? `${Lower<X>}b${Lower<Y>}` :\n//     T extends `${infer X}C${infer Y}` ? `${Lower<X>}c${Lower<Y>}` :\n//     T extends `${infer X}D${infer Y}` ? `${Lower<X>}d${Lower<Y>}` :\n//     T extends `${infer X}E${infer Y}` ? `${Lower<X>}e${Lower<Y>}` :\n//     T extends `${infer X}F${infer Y}` ? `${Lower<X>}f${Lower<Y>}` :\n//     T extends `${infer X}G${infer Y}` ? `${Lower<X>}g${Lower<Y>}` :\n//     T extends `${infer X}H${infer Y}` ? `${Lower<X>}h${Lower<Y>}` :\n//     T extends `${infer X}I${infer Y}` ? `${Lower<X>}i${Lower<Y>}` :\n//     T extends `${infer X}J${infer Y}` ? `${Lower<X>}j${Lower<Y>}` :\n//     T extends `${infer X}K${infer Y}` ? `${Lower<X>}k${Lower<Y>}` :\n//     T extends `${infer X}L${infer Y}` ? `${Lower<X>}l${Lower<Y>}` :\n//     T extends `${infer X}M${infer Y}` ? `${Lower<X>}m${Lower<Y>}` :\n//     T extends `${infer X}N${infer Y}` ? `${Lower<X>}n${Lower<Y>}` :\n//     T extends `${infer X}O${infer Y}` ? `${Lower<X>}o${Lower<Y>}` :\n//     T extends `${infer X}P${infer Y}` ? `${Lower<X>}p${Lower<Y>}` :\n//     T extends `${infer X}Q${infer Y}` ? `${Lower<X>}q${Lower<Y>}` :\n//     T extends `${infer X}R${infer Y}` ? `${Lower<X>}r${Lower<Y>}` :\n//     T extends `${infer X}S${infer Y}` ? `${Lower<X>}s${Lower<Y>}` :\n//     T extends `${infer X}T${infer Y}` ? `${Lower<X>}t${Lower<Y>}` :\n//     T extends `${infer X}U${infer Y}` ? `${Lower<X>}u${Lower<Y>}` :\n//     T extends `${infer X}V${infer Y}` ? `${Lower<X>}v${Lower<Y>}` :\n//     T extends `${infer X}W${infer Y}` ? `${Lower<X>}w${Lower<Y>}` :\n//     T extends `${infer X}X${infer Y}` ? `${Lower<X>}x${Lower<Y>}` :\n//     T extends `${infer X}Y${infer Y}` ? `${Lower<X>}y${Lower<Y>}` :\n//     T extends `${infer X}Z${infer Y}` ? `${Lower<X>}z${Lower<Y>}` :\n//     T;\n// type Cap<T extends string> =\n//     T extends `${Lower<infer X>}${infer Y}` ? `${Upper<X>}${Y}` : T;\n\n// type Uncap<T extends string> =\n//     T extends `${Upper<infer X>}${infer Y}` ? `${Lower<X>}${Y}` : T;\n\n// type Stringable = string | number | bigint | boolean | null | undefined;\n\n// eslint-disable-next-line prettier/prettier\ntype J<T extends unknown[]> =\n  T extends [] ? '' :\n  T extends [any] ? `${T[0]}` :\n  T extends [any, ...infer Y] ? `${T[0]}${J<Y>}` :\n  never;\n\n// type D2<T> = J<[T, T]>;\n// type D3<T> = J<[T, D2<T>]>;\n// type D4<T> = J<[T, D3<T>]>;\n// type D5<T> = J<[T, D4<T>]>;\n// type D6<T> = J<[T, D5<T>]>;\n// type D7<T> = J<[T, D6<T>]>;\n// type D8<T> = J<[T, D7<T>]>;\n// type D9<T> = J<[T, D8<T>]>;\n// type Many<T> = D2<T> | D3<T> | D4<T> | D5<T> | D6<T> | D7<T> | D8<T> | D9<T>;\n// type OneOrMany<T> = T | Many<T>;\n// type SingleLetter<T> = Tail<T> extends '' ? T : never;\n// type Gobble<T, U> = T extends J<[infer X, infer Y, infer Z]> ? (Y extends U ? X : J<[X, Gobble<J<[Y, Z]>, U>]>) : T;\n// type Gobble<T, U> =\n//     T extends `${infer X}${infer Y}${infer Z}`\n//     ? Y extends U\n//       ? X\n//       : `${X}${Gobble<`${T}${Z}`, U>}`\n//     : T;\n\n// type HeadTail<T> = T extends `${infer THead}${infer TTail}` ? [THead, TTail] : never;\n\n// type Head<T> = HeadTail<T> extends [infer X, any] ? X : '';\n// type Tail<T> = HeadTail<T> extends [any, infer X] ? X : '';\n\n// type Train<T> = T extends string ? Train<ToCharArray<T>> : T extends [...infer TFront, infer TCaboose] ? [FromCharArray<TFront>, TCaboose] : never;\n\n// type Front<T> = Train<T> extends [infer X, any] ? X : '';\n// type Caboose<T> = Train<T> extends [any, infer X] ? X : '';\n\ntype ToCharArray<T> = T extends '' ? [] : T extends J<[infer X, infer Y]> ? [X, ...ToCharArray<Y>] : never;\ntype FromCharArray<T extends unknown[]> = T extends []\n  ? ''\n  : T extends [string]\n  ? T[0]\n  : T extends [string, ...infer Y]\n  ? J<[T[0], FromCharArray<Y>]>\n  : never;\n\ntype Reverse<T> = T extends '' ? '' : T extends J<[infer X, infer Y]> ? J<[Reverse<Y>, X]> : never;\n\ntype InsertBefore<TInput, TSearch, TInsert> = TInput extends J<[infer X, infer Y, infer Z]>\n  ? Y extends TSearch\n  ? J<[X, TInsert, Y, InsertBefore<Z, TSearch, TInsert>]>\n  : J<[X, InsertBefore<J<[Y, Z]>, TSearch, TInsert>]>\n  : TInput;\n\n// type SnakeCase<T extends string> =\n//     T extends Lower<T> ? T :\n\n//     T extends `${Lower<infer X>}${Upper<infer Y>}${Cap<infer Z>}` ? SnakeCase<`${X}${Y}${Lowercase<Z>}`> :\n//     T extends `${Lower<infer X>}${Cap<infer Y>}` ? `${X}_${SnakeCase<Uncapitalize<Y>>}` :\n//     T extends `${Lower<infer X>}${Uncap<infer Y>}` ? `${X}${SnakeCase<Y>}` :\n//     T extends Cap<T> ? SnakeCase<Uncapitalize<T>> :\n//     1;\n// type DashCase<T extends string> = Replace<SnakeCase<T>, '_', '-'>;\n\nexport type SnakeCase<T extends string> = Uppercase<InsertBefore<T, UpperCaseChar, '_'>>;\nexport type DashCase<T extends string> = Lowercase<InsertBefore<T, UpperCaseChar, '-'>>;\ntype pdpd = SnakeCase<'ProperID4Form'>;\ntype spdpd = DashCase<'Pro5per1ID4Form'>;\n\n\n"]}