{"version":3,"file":"restify.js","sourceRoot":"","sources":["../src/restify.ts"],"names":[],"mappings":"AACA,MAAM,CAAC,GAAkB,MAAM,CAAC,GAAG,CAAC,CAAC;AAErC,SAAS,IAAI,CAAmB,MAAS;IACvC,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE;QAChC,YAAY,EAAE,KAAK;QACnB,UAAU,EAAE,KAAK;QACjB,QAAQ,EAAE,KAAK;QACf,KAAK,EAAE,IAAI;KACZ,CAAC,CAAC;IACH,OAAO,MAAa,CAAC;AACvB,CAAC;AAuBD,MAAM,UAAU,OAAO,CAAC,GAAQ;IAC9B,IAAI,GAAG,KAAK,SAAS,EAAE;QACrB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;KACjB;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACrB,CAAC;AA0BD,MAAM,UAAU,SAAS,CAAC,GAAQ;IAChC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;QACX,OAAO,GAAG,CAAC;KACZ;IACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACvB,MAAM,IAAI,SAAS,CAAC,wBAAwB,CAAC,CAAC;KAC/C;IACD,QAAQ,GAAG,CAAC,MAAM,EAAE;QAClB,KAAK,CAAC;YACJ,OAAO;QACT,KAAK,CAAC;YACJ,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;QAChB;YACE,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,yBAAyB;KAC7C;AACH,CAAC","sourcesContent":["import { AssertNever } from './Error';\nconst Ξ: unique symbol = Symbol(\"⚡\");\ntype mark<T extends object> = T & { readonly [Ξ]: true; }\nfunction mark<T extends object>(target: T): mark<T>{\n  Reflect.defineProperty(target, Ξ, {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: true,\n  });  \n  return target as any;\n}\n\n\n/**\n * Changes scalers back into the array type from\n * whence they came.\n * \n * Payload signatures are collected by 'un-spreading'\n * the reducer function's argument list into an \n * array, unless it's a single value -- in that \n * case the value stands on its own (makes for \n * cleaner / easier to read devtools and the like).\n * \n * Types that get modified are marked with a 'Ξ' so\n * that later we can tell the difference between them\n * and single arrays that passed through untouched.\n */\nexport type restify<Œ> =\n  Œ extends void | null | undefined ? mark<[]> :\n  Œ extends any[] ? Œ :\n  mark<[Œ]>;\n\nexport function restify<Ø>(arg: Ø): restify<Ø>;\nexport function restify(arg: any) {\n  if (arg === undefined) {\n    return mark([]);\n  }\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n  return mark([arg]);\n}\n \n/**\n * Changes tuples/arrays (extracted from fn signatures) into a scaler (if\n * possible).\n * \n * Useful when payloads are captured as an array in fn.apply. The resulting\n * type will be that array, unless, it is empty (then void) or a single item\n * (that single value will be extracted). This is all in effor to make devtools\n *  and whatnot look a lot cleaner.\n * \n * The Ξ markers are there to clarify whether payloads composed of a single\n * array-typed value are intended to be spread on the reducer or are actually\n * a single array parameter.\n */\nexport type unrestify<Ω extends any[]> =\n  Ω extends mark<infer Δ> ? (\n    Δ extends [infer φ] | [infer Θ] ? φ | Θ :\n    Δ extends [infer φ] ? φ :\n    Δ extends [] ? void :\n    Δ extends any[] ? Δ ://InvalidTypeArg<`unrestify<T>`, [T: Ω, U: Δ], `Encountered a plain ol' array where a tuple should be specified. Somewhere along the way this type has beed widened and the type information lost.` > :\n    AssertNever< `unrestify<T>`, [T: Ω], `The 'Ξ' marker should only be dropped on arrays, and I'm pretty sure that I've already exhaustively checked for that. How the hell did you land here?` >\n  )\n  : Ω;\n\nexport function unrestify<Ħ extends any[]>(arg: Ħ): unrestify<Ħ>;\nexport function unrestify(arg: any) {\n  if (!arg[Ξ]) {\n    return arg;\n  }\n  if (!Array.isArray(arg)) {\n    throw new TypeError(\"Value must be an array\");\n  }\n  switch (arg.length) {\n    case 0:\n      return;\n    case 1:\n      return arg[0];\n    default:\n      return [...arg]; //clear the marker symbol\n  }\n}\n"]}