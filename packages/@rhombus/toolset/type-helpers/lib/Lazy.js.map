{"version":3,"file":"Lazy.js","sourceRoot":"","sources":["../src/Lazy.ts"],"names":[],"mappings":";AAAA,8CAA8C;AAC9C,gCAAgC;AAEhC,qDAAqD;AAErD,qBAAqB;AACrB,4CAA4C;AAC5C,iDAAiD;AAEjD,uFAAuF;AACvF,qGAAqG;AACrG,iCAAiC;AACjC,yCAAyC;AACzC,oBAAoB;AACpB,sEAAsE;AACtE,mBAAmB;AACnB,YAAY;AACZ,cAAc;AACd,IAAI;AAEJ,uCAAuC;AACvC,uGAAuG;AACvG,gGAAgG;AAChG,IAAI;AAEJ,mHAAmH;AACnH,gHAAgH;AAChH,KAAK","sourcesContent":["// import { Ctor, Func } from '@rhombus/func';\r\n// import * as obj from './obj';\r\n\r\n// export function Lazy<T extends Ctor>(ctor: T): T {\r\n\r\n//     return class {\r\n//         constructor(...ctorArgs: any[]) {\r\n//             let ref: WeakRef<InstanceType<T>>;\r\n\r\n//             return new Proxy({}, mapValues(Reflect, (key, fn) => (...args: any) => {\r\n//                 const target = ref?.deref() ?? (ref = new WeakRef(new ctor(...ctorArgs))).deref();\r\n//                 if (!target) {\r\n//                     throw 'wtf mate?';\r\n//                 }\r\n//                 return fn(target, ...args.slice(1) as GoddamnTuple)\r\n//             }));\r\n//         }\r\n//     } as T;\r\n// }\r\n\r\n// type GoddamnTuple = [any, any, any];\r\n// function mapValues<T extends Record<PropertyKey, any>, R>(source: T, map: Func<obj.entries<T>, R>) {\r\n//     return obj.fromEntries(entries(source).map(([key, fn]) => [key, map(key, fn)] as const));\r\n// }\r\n\r\n// function entries<T extends object>(p: T): obj.entries<T>[] { // eslint-disable-line @typescript-eslint/ban-types\r\n//     return Reflect.ownKeys(p).filter(p => typeof p === 'string').map(key => [key, p[key as keyof T]]) as any;\r\n// };\r\n"]}