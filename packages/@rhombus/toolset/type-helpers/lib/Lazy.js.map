{"version":3,"file":"Lazy.js","sourceRoot":"","sources":["../src/Lazy.ts"],"names":[],"mappings":";AAAA,8CAA8C;AAC9C,gCAAgC;AAEhC,qDAAqD;AAErD,qBAAqB;AACrB,4CAA4C;AAC5C,iDAAiD;AAEjD,uFAAuF;AACvF,qGAAqG;AACrG,iCAAiC;AACjC,yCAAyC;AACzC,oBAAoB;AACpB,sEAAsE;AACtE,mBAAmB;AACnB,YAAY;AACZ,cAAc;AACd,IAAI;AAEJ,uCAAuC;AACvC,uGAAuG;AACvG,gGAAgG;AAChG,IAAI;AAEJ,mHAAmH;AACnH,gHAAgH;AAChH,KAAK","sourcesContent":["// import { Ctor, Func } from '@rhombus/func';\n// import * as obj from './obj';\n\n// export function Lazy<T extends Ctor>(ctor: T): T {\n\n//     return class {\n//         constructor(...ctorArgs: any[]) {\n//             let ref: WeakRef<InstanceType<T>>;\n\n//             return new Proxy({}, mapValues(Reflect, (key, fn) => (...args: any) => {\n//                 const target = ref?.deref() ?? (ref = new WeakRef(new ctor(...ctorArgs))).deref();\n//                 if (!target) {\n//                     throw 'wtf mate?';\n//                 }\n//                 return fn(target, ...args.slice(1) as GoddamnTuple)\n//             }));\n//         }\n//     } as T;\n// }\n\n// type GoddamnTuple = [any, any, any];\n// function mapValues<T extends Record<PropertyKey, any>, R>(source: T, map: Func<obj.entries<T>, R>) {\n//     return obj.fromEntries(entries(source).map(([key, fn]) => [key, map(key, fn)] as const));\n// }\n\n// function entries<T extends object>(p: T): obj.entries<T>[] { // eslint-disable-line @typescript-eslint/ban-types\n//     return Reflect.ownKeys(p).filter(p => typeof p === 'string').map(key => [key, p[key as keyof T]]) as any;\n// };\n"]}