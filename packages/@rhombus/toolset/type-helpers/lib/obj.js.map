{"version":3,"file":"obj.js","sourceRoot":"","sources":["../src/obj.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,IAAI,CAAI,GAAM;IAC1B,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAQ,CAAC;AACnC,CAAC;AAKD,MAAM,UAAU,OAAO,CAAI,GAAM;IAC7B,OAAO,MAAM,CAAC,OAAO,CAAC,GAAG,CAAQ,CAAC;AACtC,CAAC;AAGD,MAAM,UAAU,MAAM,CAAI,GAAM;IAC5B,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC9B,CAAC;AAMD,MAAM,UAAU,WAAW,CAA4C,OAAgB;IACnF,OAAO,MAAM,CAAC,WAAW,CAAC,OAAO,CAAQ,CAAC;AAC9C,CAAC;AASD,wDAAwD;AACxD,MAAM,UAAU,MAAM,CAAoC,MAAS,EAAE,GAAG,OAAU;IAC9E,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,OAAO,CAAC,CAAC;AAC7C,CAAC;AAED,MAAM,UAAU,UAAU,CAAqC,MAAS,EAAE,KAAQ;IAC9E,IAAI,CAAC,CAAC,MAAM,YAAY,MAAM,CAAC,EAAE;QAC/B,MAAM,IAAI,UAAU,CAAC,8DAA8D,CAAC,CAAC;KACtF;IACD,IAAI,OAAO,GAAQ,MAAM,CAAC;IAC1B,OAAO,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,WAAW,IAAI,OAAO,CAAC,cAAc,CAAC,OAAO,CAAE,CAAC,WAAW,KAAK,MAAM,EAAE;QAC9G,OAAO,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAE,CAAC;KAC5C;IACD,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC/D,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AACtC,CAAC","sourcesContent":["\nexport type keys<T> = keyof T;\nexport function keys<T>(obj: T): keys<T>[] {\n    return Object.keys(obj) as any;\n}\n\nexport type entries<T> = {\n    [K in keyof T]: [K, T[K]]\n}[keyof T]\nexport function entries<T>(obj: T): entries<T>[]{\n    return Object.entries(obj) as any;\n}\n\nexport type values<T> = T[keyof T];\nexport function values<T>(obj: T): values<T>[] {\n    return Object.values(obj);\n}\n\n\nexport type fromEntries<TUnion extends readonly [PropertyKey, any]> = {\n    [Entry in TUnion as Entry[0]]: Entry[1]\n}\nexport function fromEntries<TPair extends readonly [PropertyKey, any]>(entries: TPair[]): fromEntries<TPair> {\n    return Object.fromEntries(entries) as any;\n}\n\ntype MergeTarget<Target, Source> =\n    Source extends Partial<Target> ? Target : Target & Source;\ntype CompileArray<Target, Sources extends any[]> =\n    Sources extends [...infer Rest, infer Source] ? CompileArray<MergeTarget<Target, Source>, Rest> :\n    Sources extends [infer Source] ? MergeTarget<Target, Source> :\n    Sources extends [] ? Target :\n    Target;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function assign<T extends object, A extends any[]>(target: T, ...sources: A): CompileArray<T, A> {\n    return Object.assign(target, ...sources);\n}\n\nexport function assignDeep<A extends object, B extends object>(target: A, stuff: B): A & B {\n    if (!(target instanceof Object)) {\n      throw new RangeError('this function only useful on things with an Object prototype');\n    }\n    let current: any = target;\n    while (Reflect.getPrototypeOf(current)?.constructor && Reflect.getPrototypeOf(current)!.constructor !== Object) {\n      current = Reflect.getPrototypeOf(current)!;\n    }\n    Reflect.setPrototypeOf(current, Reflect.getPrototypeOf(stuff));\n    return Object.assign(target, stuff);\n  }\n"]}