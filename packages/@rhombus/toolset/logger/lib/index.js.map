{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Action } from '@rhombus/func';\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-console */\n\n// export interface MemoryInfo {\n//     jsHeapSizeLimit: number;\n//     totalJSHeapSize: number;\n//     usedJSHeapSize: number;\n// }\n// export type Logger = {\n//     [K in keyof Omit<Console, 'memory'>]: (...args: Parameters<Console[K]>) => void;\n// };\n// // function createLogger(implementation: <K extends keyof Logger>(key: K) => Logger[K]) {\n// function createLogger(source: Logger) {\n//     return keys(source).reduce((logger, key) => {\n//         logger[key] = (...args: any[]) => {\n//             (source[key] as any)(...args);\n//             return logger;\n//         };\n//         return logger;\n//     }, {} as Logger);\n\n// }\ntype RemapReturns<T> = {\n    [K in keyof T]: T[K] extends Action ? <Args extends Parameters<T[K]>>(...args: Args) => (\n        Args extends [...any[], infer Last] ? Last : T\n    ) : T[K]\n};\n\nexport type LoggerBase = RemapReturns<Console>;\ntype CreateLoggerResult<T extends LoggerBase = LoggerBase> = readonly [logger:T, enableLogging:Action<[enable?:boolean]>];\nexport function createLogger(enabled = false):CreateLoggerResult {\n    let _enabled = enabled;\n    function enableLogging(enable = true) {\n        _enabled = enable;\n    }\n    const logger: LoggerBase = new Proxy(console, {\n        get: function (target: any, prop, receiver) {\n            return (...args: [any, ...any]) => {\n                if (_enabled) {\n                    target[prop](...args);\n                }\n                return args.length ? args.slice(-1)[0] : target;\n            };\n        }\n    });\n    return [logger, enableLogging] as const;\n}\nexport function createNoopLogger(): CreateLoggerResult {\n    function enableLogging(enable = true) {\n    }\n    const logger: LoggerBase = new Proxy(console, {\n        get: function (target: any, prop, receiver) {\n            return (...args: [any, ...any]) => {\n                return args.length ? args.slice(-1)[0] : target;\n            };\n        }\n    });\n    return [logger, enableLogging] as const;\n}\nexport const [logger, enableLogging] = createLogger();\n\n\n// function keys<T>(obj: T) {\n//     return Object.keys(obj) as Array<keyof T>;\n// }\n\n// export abstract class LoggerBase implements Logger {\n//     // abstract log: (...args: any) => this;\n//     // warn = (...args: any) => this.error('This implementation does not support this method');\n//     // error = (...args: any) => this.error('This implementation does not support this method');\n//     // count = (label?: string) => this.error('This implementation does not support this method');\n//     // countReset = (label?: string) => this.error('This implementation does not support this method');\n//     // clear = () => this.error('This implementation does not support this method');\n//     // assert = (condition?: boolean, ...data: any[]) => this.error('This implementation does not support this method');\n\n//     assert = (condition?: boolean, ...data: any[]) => this.error('This implementation does not support this method');\n//     clear = () => this.error('This implementation does not support this method');\n//     count = (label?: string) => this.error('This implementation does not support this method');\n//     countReset = (label?: string) => this.error('This implementation does not support this method');\n//     debug = (...data: any[]) => this.error('This implementation does not support this method');\n//     dir = (item?: any, options?: any) => this.error('This implementation does not support this method');\n//     dirxml = (...data: any[]) => this.error('This implementation does not support this method');\n//     abstract error: (...data: any[]) => this;\n//     exception = (message?: string, ...optionalParams: any[]) => this.error('This implementation does not support this method');\n//     group = (...data: any[]) => this.error('This implementation does not support this method');\n//     groupCollapsed = (...data: any[]) => this.error('This implementation does not support this method');\n//     groupEnd = () => this.error('This implementation does not support this method');\n//     info = (...data: any[]) => this.error('This implementation does not support this method');\n//     abstract log: (...data: any[]) => this;\n//     table = (tabularData?: any, properties?: string[]) => this.error('This implementation does not support this method');\n//     time = (label?: string) => this.error('This implementation does not support this method');\n//     timeEnd = (label?: string) => this.error('This implementation does not support this method');\n//     timeLog = (label?: string, ...data: any[]) => this.error('This implementation does not support this method');\n//     timeStamp = (label?: string) => this.error('This implementation does not support this method');\n//     trace = (...data: any[]) => this.error('This implementation does not support this method');\n//     abstract warn: (...data: any[]) => this;\n// };\n\n// export class NoopLogger extends LoggerBase {\n//     get memory() {\n//         return undefined;\n//     }\n//     set memory(val) {\n\n//     }\n//     error = (...data: any[]) => this;\n//     log = (...data: any[]) => this;\n//     warn = (...data: any[]) => this;\n\n// }\n\n// function makeThisReturn<T extends LoggerBase, K extends keyof Console>(thisArg: T, method: K): (...args: Parameters<Console[K]>) => T {\n//     return (...args: Parameters<Console[K]>) => {\n//         console[method](...args);\n//         return thisArg;\n//     };\n// }\n// export class DynamicLogger implements Logger {\n//     constructor(implementation: <K extends keyof Logger>(key: K) => Logger[K]) {\n\n//         for (const key of (Object.keys(console) as Array<keyof Logger>)) {\n//             this[key] = implementation(key);\n//             return this;\n//         }\n//     }\n//     // assert(condition?: boolean, ...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // clear(): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // count(label?: string): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // countReset(label?: string): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // debug(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // dir(item?: any, options?: any): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // dirxml(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // error(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // exception(message?: string, ...optionalParams: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // group(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // groupCollapsed(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // groupEnd(): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // info(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // log(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // table(tabularData?: any, properties?: string[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // time(label?: string): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // timeEnd(label?: string): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // timeLog(label?: string, ...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // timeStamp(label?: string): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // trace(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n//     // warn(...data: any[]): void {\n//     //     throw new Error('Method not implemented.');\n//     // }\n// }\n// export class ConsoleLogger extends LoggerBase {\n//     constructor() {\n//         super();\n//         for (const key of (Object.keys(console) as Array<keyof Console>)) {\n//             this[key] = makeThisReturn(this, key);\n//             return this;\n//         }\n//     }\n//     get memory() {\n//         return console.memory;\n//     }\n//     set memory(val) {\n//         console.memory = val;\n//     }\n//     error = (...data: any[]) => {\n//         console.error(...data);\n//         return this;\n//     };\n//     log = (...data: any[]) => {\n//         console.log(...data);\n//         return this;\n//     };\n//     warn = (...data: any[]) => {\n//         console.warn(...data);\n//         return this;\n//     };\n\n// }\n"]}